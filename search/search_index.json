{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wrechie NOTE: This project is undergoing major changes so this documentation is OUTDATED . wrechie , a general purpose programming environment that runs wren . It currently packed with features such as: relative import ( import \"./module\" ) built-in package import ( import \"package\" )","title":"Home"},{"location":"#wrechie","text":"","title":"Wrechie"},{"location":"#note-this-project-is-undergoing-major-changes-so-this-documentation-is-outdated","text":"wrechie , a general purpose programming environment that runs wren . It currently packed with features such as: relative import ( import \"./module\" ) built-in package import ( import \"package\" )","title":"NOTE: This project is undergoing major changes so this documentation is OUTDATED."},{"location":"api/path/","text":"Path Path , a builtin class packed with common pathname manipulation. To use this class, import \"path\" for Path Path.sep Directory seperator. On unix system, it is / while on windows, it is \\ . Path.dirname(path) Returns the directory name of pathname path . For instance, the result of Path.dirname(\"/cow/data.txt\") is \"/cow\" . Path.filename(path) Returns the filename of pathname path , including its extension. For instance, the result of Path.filename(\"/cow/data.txt\") is \"data.txt\" . Path.filebase(path) Returns the filename of pathname path without its extension . For instance, the result of Path.filebase(\"/cow/data.txt\") is \"data\" . Path.splitext(path) Returns a list consisting the root and the extension of pathname path . For instance, the result of Path.splitext(\"/cow/data.txt\") is [\"/cow/data\", \".txt\"] . Path.ext(path) Returns the extension of pathname path . For instance, the result of Path.splitext(\"/cow/data.txt\") is \".txt\" . The result is same as Path.splitext(path)[0] . Path.split(path) Returns a list consisting the component of pathname path . For instance, the result of Path.split(\"/cow/data.txt\") is [\"cow\", \"data.txt\"] . Path.join(list) Returns a pathname joined from a list of path list . For instance, the result of Path.join([\"/cow\",\"data.txt\"]) is \"/cow/data.txt\" . Elements of the list must be string. NOTE : path != Path.join(Path.split(path)) . This is because Path.split() do strip off the leading / . Path.select(path, begin, [end]) Returns a new pathname in which it is sliced from pathname path starts from begin to end . Examples: Path.select(\"/path/to/foo/bar.txt\", 2) # foo/bar.txt Path.select(\"/path/to/foo/bar.txt\", 2, 3) # foo/ Path.normpath(path) Returns a normalized pathname from pathname path . Examples: Path.normpath(\"/path/../foo/bar.txt\") # /foo/bar.txt Path.select(\"/path/to/./bar.txt\") # /path/to/bar.txt Path.commonprefix(list) Returns the common prefix of pathnames in list . Examples: Path.commonprefix([ \"/path/to/id=000/file.txt\", \"/path/to/id=001/file.txt\" ]) # /path/to/id=00 NOTE : It might give invalid pathname. To obtain a valid path, use Path.commondirname(list) instead. Path.commondirname(list) Returns the common directory of pathnames in list . Examples: Path.commondirname([ \"/path/to/id=000/file.txt\", \"/path/to/id=001/file.txt\" ]) # /path/to Path.exists(path) Returns true if the pathname path exists or not, else false .","title":"Path"},{"location":"api/path/#path","text":"Path , a builtin class packed with common pathname manipulation. To use this class, import \"path\" for Path","title":"Path"},{"location":"api/path/#pathsep","text":"Directory seperator. On unix system, it is / while on windows, it is \\ .","title":"Path.sep"},{"location":"api/path/#pathdirnamepath","text":"Returns the directory name of pathname path . For instance, the result of Path.dirname(\"/cow/data.txt\") is \"/cow\" .","title":"Path.dirname(path)"},{"location":"api/path/#pathfilenamepath","text":"Returns the filename of pathname path , including its extension. For instance, the result of Path.filename(\"/cow/data.txt\") is \"data.txt\" .","title":"Path.filename(path)"},{"location":"api/path/#pathfilebasepath","text":"Returns the filename of pathname path without its extension . For instance, the result of Path.filebase(\"/cow/data.txt\") is \"data\" .","title":"Path.filebase(path)"},{"location":"api/path/#pathsplitextpath","text":"Returns a list consisting the root and the extension of pathname path . For instance, the result of Path.splitext(\"/cow/data.txt\") is [\"/cow/data\", \".txt\"] .","title":"Path.splitext(path)"},{"location":"api/path/#pathextpath","text":"Returns the extension of pathname path . For instance, the result of Path.splitext(\"/cow/data.txt\") is \".txt\" . The result is same as Path.splitext(path)[0] .","title":"Path.ext(path)"},{"location":"api/path/#pathsplitpath","text":"Returns a list consisting the component of pathname path . For instance, the result of Path.split(\"/cow/data.txt\") is [\"cow\", \"data.txt\"] .","title":"Path.split(path)"},{"location":"api/path/#pathjoinlist","text":"Returns a pathname joined from a list of path list . For instance, the result of Path.join([\"/cow\",\"data.txt\"]) is \"/cow/data.txt\" . Elements of the list must be string. NOTE : path != Path.join(Path.split(path)) . This is because Path.split() do strip off the leading / .","title":"Path.join(list)"},{"location":"api/path/#pathselectpath-begin-end","text":"Returns a new pathname in which it is sliced from pathname path starts from begin to end . Examples: Path.select(\"/path/to/foo/bar.txt\", 2) # foo/bar.txt Path.select(\"/path/to/foo/bar.txt\", 2, 3) # foo/","title":"Path.select(path, begin, [end])"},{"location":"api/path/#pathnormpathpath","text":"Returns a normalized pathname from pathname path . Examples: Path.normpath(\"/path/../foo/bar.txt\") # /foo/bar.txt Path.select(\"/path/to/./bar.txt\") # /path/to/bar.txt","title":"Path.normpath(path)"},{"location":"api/path/#pathcommonprefixlist","text":"Returns the common prefix of pathnames in list . Examples: Path.commonprefix([ \"/path/to/id=000/file.txt\", \"/path/to/id=001/file.txt\" ]) # /path/to/id=00 NOTE : It might give invalid pathname. To obtain a valid path, use Path.commondirname(list) instead.","title":"Path.commonprefix(list)"},{"location":"api/path/#pathcommondirnamelist","text":"Returns the common directory of pathnames in list . Examples: Path.commondirname([ \"/path/to/id=000/file.txt\", \"/path/to/id=001/file.txt\" ]) # /path/to","title":"Path.commondirname(list)"},{"location":"api/path/#pathexistspath","text":"Returns true if the pathname path exists or not, else false .","title":"Path.exists(path)"},{"location":"user_manual/getting_started/","text":"Getting started Compiling wrechie To get the source of wrechie , git clone https://github.com/RechieKho/wrechie.git And the source will be in the folder wrechie/ located in where you execute the git command. Then, compile it. cd wrechie/ scons And you should have wrechie living inside of dist/ folder. Your first wren script Here is a very basic hello world in wren . # hello_world.wren System.print(\"Hello world!\") Save it in hello_world.wren and run the script by calling wrechie hello_world.wren . NOTE : If you haven't put wrechie onto your PATH environment variable, then you should give the full path of wrechie to the terminal, such as path/to/wrechie hello_world.wren And you run your first script! Yay! It is advisable to read about the wren scripting language before going any futher as we won't be discussing about about to code in wren .","title":"Getting started"},{"location":"user_manual/getting_started/#getting-started","text":"","title":"Getting started"},{"location":"user_manual/getting_started/#compiling-wrechie","text":"To get the source of wrechie , git clone https://github.com/RechieKho/wrechie.git And the source will be in the folder wrechie/ located in where you execute the git command. Then, compile it. cd wrechie/ scons And you should have wrechie living inside of dist/ folder.","title":"Compiling wrechie"},{"location":"user_manual/getting_started/#your-first-wren-script","text":"Here is a very basic hello world in wren . # hello_world.wren System.print(\"Hello world!\") Save it in hello_world.wren and run the script by calling wrechie hello_world.wren . NOTE : If you haven't put wrechie onto your PATH environment variable, then you should give the full path of wrechie to the terminal, such as path/to/wrechie hello_world.wren And you run your first script! Yay! It is advisable to read about the wren scripting language before going any futher as we won't be discussing about about to code in wren .","title":"Your first wren script"},{"location":"user_manual/import/","text":"Importing stuff Importing makes your project modular. There are two type of import in wrechie : Relative import Package import Relative import Relative import means import another wren script by specifying the path relative to the current wren script. Here is our example directory: src\\ - main.wren - module.wren To import module.wren from main.wren , in main.wren , you just need to type this out: import \"./module\" for Something the path given to the import statment must start with either ./ or ../ . The path given should be in unix-style path, which mean using / instead of \\ for directory seperator (even if you are in windows). The extension ( .wren ) is automatically appended. Package import Package import means importing a package. For now, you can only import built-in packages like path . To import a package, just type out the package's name. For instance, to import path : import \"path\" for Path Write your own build-in package To write your own build-in package, you'll need to know how to compile wrechie from source . Get into wrechie source code. Then, you'll be overwhelmed by lots of folders. But here, we'll be only focusing on the wrenfiles/ folder. Every single wren script in this folder will be packed into wrechie as built-in package. The rules: The name of the wren script will be the package name, so choose it wisely . Relative imports are only for people who know what they are doing as it won't work as intended. What happens to Relative import here? Well, all the script in wrenfiles/ will get packed into wrechie and they are not living in a directory. When you do relative import in built-in packages, it will instead import scripts relative to the script that imports the built-in package Here we'll write a Greeter class that greet us. # greeter.wren class Greeter{ sayHello(){ System.print(\"Hello world\") } } Save it in greeter.wren . Now, you just need to compile wrechie again and it will be packed into wrechie automatically. To test whether is it working, let's write a test script. # test.wren import \"greeter\" for Greeter Greeter.sayHello() Save it in test.wren . Now, run the script and it should work. $ ./dist/wrechie test.wren Hello world","title":"Importing stuff"},{"location":"user_manual/import/#importing-stuff","text":"Importing makes your project modular. There are two type of import in wrechie : Relative import Package import","title":"Importing stuff"},{"location":"user_manual/import/#relative-import","text":"Relative import means import another wren script by specifying the path relative to the current wren script. Here is our example directory: src\\ - main.wren - module.wren To import module.wren from main.wren , in main.wren , you just need to type this out: import \"./module\" for Something the path given to the import statment must start with either ./ or ../ . The path given should be in unix-style path, which mean using / instead of \\ for directory seperator (even if you are in windows). The extension ( .wren ) is automatically appended.","title":"Relative import"},{"location":"user_manual/import/#package-import","text":"Package import means importing a package. For now, you can only import built-in packages like path . To import a package, just type out the package's name. For instance, to import path : import \"path\" for Path","title":"Package import"},{"location":"user_manual/import/#write-your-own-build-in-package","text":"To write your own build-in package, you'll need to know how to compile wrechie from source . Get into wrechie source code. Then, you'll be overwhelmed by lots of folders. But here, we'll be only focusing on the wrenfiles/ folder. Every single wren script in this folder will be packed into wrechie as built-in package. The rules: The name of the wren script will be the package name, so choose it wisely . Relative imports are only for people who know what they are doing as it won't work as intended. What happens to Relative import here? Well, all the script in wrenfiles/ will get packed into wrechie and they are not living in a directory. When you do relative import in built-in packages, it will instead import scripts relative to the script that imports the built-in package Here we'll write a Greeter class that greet us. # greeter.wren class Greeter{ sayHello(){ System.print(\"Hello world\") } } Save it in greeter.wren . Now, you just need to compile wrechie again and it will be packed into wrechie automatically. To test whether is it working, let's write a test script. # test.wren import \"greeter\" for Greeter Greeter.sayHello() Save it in test.wren . Now, run the script and it should work. $ ./dist/wrechie test.wren Hello world","title":"Write your own build-in package"}]}